---
layout: post
title: Lecture 1 The Shell
nav_order: 1
description: "Lecture 1: The Shell"
permalink: /L01

---

# Lecture 1: The Shell

## Shell 与命令行工具简介

在这节课中，我们将重点介绍基于命令行或文本的工具，而 Shell 将是你进行大部分操作的地方。如果你对 Shell 不熟悉，以下是一些常见的 Shell 环境：

- **Windows** 上常见的 Shell 是 **PowerShell**，但还有其他选择。
- **Linux** 平台上有多种终端（Terminal），它们是显示 Shell 的窗口，最常见的 Shell 是 **Bash**（Bourne Again Shell）。
- **Mac OS** 上也有 Bash，尽管可能是旧版本，可以通过打开终端（Terminal App）使用。

尽管大多数工具在所有平台上都能使用，本课程将主要以 **Linux** 为中心进行讲解。无论你使用什么平台，都可以跟随课程内容，如果不知道如何安装终端和 Shell，可以在助教时间咨询我们，或者通过简单的搜索找到安装方法。

### Shell 交互基础

当你打开终端时，会看到一个类似以下的界面：

- 顶部通常有一行文本，这就是 **Shell 提示符**（Shell Prompt）。
- 提示符通常显示用户名、机器名以及当前路径（稍后会介绍路径）。
- 提示符的光标会等待你输入命令，这就是你告诉 Shell 该执行什么操作的地方。

你可以自定义这个提示符，但在本次讲座中我们不会深入讨论自定义，今天的重点是如何使用 Shell 进行实际操作。

## 执行命令

在 Shell 提示符下，你可以输入 **命令** 来与计算机交互，命令可以是简单的程序执行或带有参数的程序运行。举例：

- 输入 `date`，按下回车，Shell 会显示当前的日期和时间。
- 输入 `echo hello`，Shell 会打印出 `hello`，`echo` 是一个程序，用来输出你提供的参数。

### 参数与引号

- 参数是紧跟在命令名称后的以空格分隔的内容。例如 `echo hello world` 会输出 `hello world`。
- 如果参数中包含空格，则需要使用引号：`echo "hello world"` 或 `echo 'hello world'`。双引号和单引号的区别将在后续的 Bash 脚本讲解中讨论。
- 你还可以通过转义字符来处理单个字符，例如 `echo hello\, world`。

### Shell 程序的查找机制

当你输入 `date` 或 `echo` 等命令时，Shell 是如何知道这些程序的位置的呢？计算机会自带一些内置程序，类似于 Windows 自带的资源管理器或浏览器。Shell 会通过 **环境变量**（Environment Variables）中的配置来查找这些程序的位置。

## 环境变量与路径

Shell 不仅仅是一个执行程序的工具，它实际上也是一种编程语言，类似于你在其他编程语言中使用的结构，Shell 支持如循环、条件判断和函数定义等功能。这节课的重点是环境变量及其在 Shell 中的作用。

### 环境变量

- **环境变量** 是在启动 Shell 时自动设置的变量，比如你的主目录（Home Directory）在哪里、用户名是什么等。其中一个关键的环境变量是 **PATH**，它决定了 Shell 在执行命令时应该去哪些目录查找程序。

要查看 PATH 变量的值，可以使用以下命令：

```bash
echo $PATH
```

这将显示你的系统中用于搜索程序的所有路径，它们通常是用冒号分隔的一长串路径。当你输入命令（如 `date` 或 `echo`）时，Shell 会依次搜索这些路径中的目录，直到找到与命令名称匹配的可执行文件。

### `which` 命令

要知道系统具体执行了哪个程序，可以使用 `which` 命令。例如：

```bash
which echo
```

这将告诉你系统在执行 `echo` 命令时具体调用了哪个程序的路径。

## 路径与文件系统

文件路径是计算机中命名文件位置的方式。在 Linux 和 Mac OS 系统中，路径通过斜杠（/）分隔，而在 Windows 系统中，路径通常由反斜杠（\\）分隔。

### 绝对路径与相对路径

- **绝对路径** 是从文件系统的根目录开始，完整地指明文件所在的位置。例如 `/usr/bin/echo`，从根目录开始查找 `usr` 目录下的 `bin`，再找到 `echo` 文件。
- **相对路径** 则是相对于当前所在的目录。如果你不知道当前所在的目录，可以使用以下命令：

```bash
pwd  # 打印当前工作目录
```

`pwd` 会显示当前的完整路径。例如，如果当前目录是 `/home/john/dev`，那么 `pwd` 会输出该路径。

### 切换目录

要更改当前的工作目录，可以使用 `cd`（改变目录）命令。例如：

```bash
cd /home  # 切换到 /home 目录
```

现在你的工作目录将变为 `/home`，并且提示符会相应地改变显示。你也可以使用相对路径来切换目录：

```bash
cd ..
```

`cd ..` 会将你切换到当前目录的上一级目录（父目录）。此外，`.` 代表当前目录，`..` 代表父目录，这些特殊目录使得在文件系统中导航更加便捷。



## 路径与目录导航

在命令行环境中，理解 **相对路径** 和 **绝对路径** 是文件系统操作的基础。

### 特殊路径

- **`.`（单点）**：代表当前目录。
- **`..`（双点）**：代表上一级目录（父目录）。

通过使用这些符号，可以方便地在文件系统中导航。例如：

```bash
cd ..
```

这将把你从当前目录切换到上一级目录。如果当前在 `/home` 目录下，执行 `cd ..` 会把你带到根目录 `/`。再执行 `pwd`，可以验证你当前所在的目录位置。

### 相对路径与绝对路径

- **相对路径**：相对于当前目录。例如，`cd ./home` 将你带到当前目录下的 `home` 子目录。
- **绝对路径**：从根目录开始的完整路径，如 `/usr/bin/echo`。绝对路径适用于明确指向文件系统中的一个特定文件，不论当前工作目录在哪里，都会准确访问到目标。

举例来说，如果当前目录是 `/home/john`，执行以下命令：

```bash
cd /bin
```

你将进入 `/bin` 目录，无论你之前在哪个目录下。而 `cd ./bin` 则表示进入当前目录下的 `bin` 子目录。

### 切换目录的便捷技巧

- **`~`（波浪号）**：快速返回到用户的主目录。例如，`cd ~/dev` 会将你切换到 `/home/你的用户名/dev`。
- **`-`（连字符）**：快速切换到上一个访问的目录。例如：

```bash
cd -
```

如果你之前在 `/home`，现在在 `/root`，执行 `cd -` 会让你回到 `/home`。

### 列出当前目录的文件

命令 `ls` 可以列出当前目录中的文件。例如：

```bash
ls
```

将显示当前目录下的所有文件和子目录。如果你想列出其他目录中的文件，可以提供目录路径作为参数：

```bash
ls /home
```

这会列出 `/home` 目录中的文件。

## 获取命令帮助

大多数命令支持 `--help` 参数，提供关于该命令的详细信息。例如：

```bash
ls --help
```

这将显示 `ls` 命令的用法及支持的选项。通常，带有单个破折号（`-`）和单个字母的参数被称为**标志（flag）**，而带有双破折号（`--`）和完整单词的参数则称为**选项（option）**。

### 示例

- **`-a`** 或 **`--all`**：显示包括隐藏文件在内的所有文件。
- **`ls -a`**：列出当前目录中的所有文件，包括以 `.` 开头的隐藏文件。

## 文件权限与目录权限

在 Unix 系统中，文件和目录的权限是控制访问的重要机制，尤其在多用户环境中，理解权限可以帮助你更好地管理文件和安全。

### `ls -l` 命令

通过执行 `ls -l`，你可以获取当前目录下文件和目录的详细信息：

```bash
ls -l
```

这个命令输出的不仅仅是文件名，还包括文件类型、权限、所有者、所属组、文件大小和修改时间等信息。输出的第一列包含文件的权限信息，由 10 个字符组成。格式如下：

```
drwxr-xr-x  1 user group  size  date  name
```

- d    rwx   r-x   r-x
- **第一个字符**表示文件类型：`d` 表示目录，`-` 表示普通文件。
- 接下来的三个字符表示所有者的权限：读（`r`）、写（`w`）、执行（`x`）。
- 中间三个字符表示所属组的权限。
- 最后三个字符表示其他用户的权限。

### 文件权限的含义

- **读权限（r）**：允许查看文件内容。
- **写权限（w）**：允许修改或写入文件。
- **执行权限（x）**：允许执行文件（如脚本或程序）。

### 目录权限的含义

目录的权限与文件的权限稍有不同：

- **读权限（r）**：允许列出目录中的文件（类似于 `ls` 命令的效果）。
- **写权限（w）**：允许在目录中创建、删除或重命名文件。
- **执行权限（x）**：允许进入目录（即执行 `cd` 命令）。如果没有执行权限，即使拥有读权限也不能进入该目录。

### 实例

假设执行以下命令：

```bash
ls -l /bin
```

输出结果中的每一行都展示了文件或目录的详细信息。比如：

```
-rwxr-xr-x  1 root root  12345 Jan 1 12:00  echo
```

- 这个文件是可执行的（`x`），因此任何用户都可以运行这个 `echo` 程序。
- 所有者是 `root`，而所有者、组和其他用户都有执行该文件的权限。

### 特殊权限

有时候，你可能会看到权限列中有 **S**、**T** 或 **L** 等字符。这些是特殊的权限标记：

- **SUID (Set User ID)**：当文件具有 SUID 位时，任何用户执行该文件时都会临时拥有该文件所有者的权限。
- **SGID (Set Group ID)**：当目录设置了 SGID 位时，新创建的文件将自动继承该目录的组权限。
- **Sticky Bit**：在目录上设置时，只有文件的所有者或超级用户才能删除该目录中的文件，常用于公共目录。

这些特殊权限在某些高级场景中可能会用到，但对于日常使用来说，它们并不常见。

### 切换目录权限实例

例如，要进入 `/usr/bin/echo` 文件所在的目录，需要在路径上所有父目录都拥有执行权限：

```bash
cd /usr/bin
```

如果没有对 `root`、`usr` 或 `bin` 目录的执行权限，即使文件本身是可执行的，你也无法访问。

### 快速查找帮助

如前所述，大多数命令支持 `--help` 参数，显示该命令的使用说明。例如：

```bash
ls --help
```

这将输出关于 `ls` 命令的所有可选项及其用法说明。

通过理解文件权限与目录权限，你可以更加安全和高效地在多用户环境中管理文件和资源。

## 基本文件操作命令

在 Unix/Linux 系统中，使用命令行进行文件和目录操作是非常常见的。以下是一些常用的文件操作命令：

### `mv` 命令（移动/重命名）

`mv` 命令可以用于移动文件或重命名文件。它接受两个参数：源路径和目标路径。如果目标路径是一个文件名，那么文件将被重命名；如果目标路径是一个目录，文件将被移动到该目录中。

**示例**：

```bash
mv file.txt newfile.txt  # 重命名文件
mv file.txt /home/user/  # 将文件移动到指定目录
```

### `cp` 命令（复制）

`cp` 命令用于复制文件或目录。它也接受两个参数：源路径和目标路径。你可以复制文件到同一目录下并使用不同的文件名，或者将文件复制到其他目录。

**示例**：

```bash
cp file.txt backup.txt  # 复制文件并重命名
cp file.txt /home/user/  # 复制文件到指定目录
```

### `rm` 命令（删除）

`rm` 命令用于删除文件。如果要删除一个目录，通常需要使用 `-r` 选项来递归删除目录及其下的所有内容。

**示例**：

```bash
rm file.txt             # 删除文件
rm -r /home/user/docs/  # 递归删除目录及其内容
```

需要注意的是，`rm` 命令删除的文件不会进入“回收站”，因此删除操作是不可逆的。

### `rmdir` 命令（删除空目录）

`rmdir` 仅能删除空的目录。如果目录中还有文件或子目录，删除操作会失败。

**示例**：

```bash
rmdir emptydir  # 删除空目录
```

### `mkdir` 命令（创建目录）

`mkdir` 用于创建新目录。需要注意的是，如果目录名中包含空格，你需要使用引号或转义空格。

**示例**：

```bash
mkdir newdir         # 创建新目录
mkdir "my photos"    # 目录名包含空格时，需要使用引号
```

### `man` 命令（获取手册）

`man` 命令用于查看程序的手册页面。你可以输入 `man` 加上命令名称来查看该命令的详细说明及使用方法。

**示例**：

```bash
man ls  # 查看 ls 命令的手册
```

`man` 命令的手册页面通常比 `--help` 选项更加详细，并且会提供命令的使用示例和额外信息。手册页面中可以通过按 `q` 退出。

## 输入与输出流重定向

在 Shell 中，**重定向** 是非常强大的功能，它允许你将程序的输入和输出流指向不同的目标，而不仅仅是键盘和终端。重定向可以通过角括号和管道符实现，帮助你将多个命令组合起来执行复杂的操作。

### 基本重定向

- **输出重定向 (`>`)**：将程序的输出重定向到文件。如果文件已存在，内容将被覆盖。例如：

    ```bash
    echo "hello" > hello.txt
    ```

    这会将 `echo "hello"` 的输出保存到 `hello.txt` 文件中，而不会显示在终端上。

- **输入重定向 (`<`)**：将文件内容作为程序的输入。例如，使用 `cat` 读取 `hello.txt`：

    ```bash
    cat < hello.txt
    ```

    这会将 `hello.txt` 的内容作为输入传递给 `cat`，并将输出打印到终端。

- **追加 (`>>`)**：与 `>` 类似，但不会覆盖文件内容，而是追加到文件末尾。例如：

    ```bash
    echo "world" >> hello.txt
    ```

    这会将 "world" 追加到 `hello.txt` 文件的末尾。

### 管道 (`|`)

管道符号 (`|`) 是 Shell 中的另一个重要功能，它允许将一个程序的输出直接作为下一个程序的输入。例如：

```bash
ls -l / | tail -n 1
```

- **`ls -l /`**：列出根目录 `/` 中的所有文件和目录。
- **`tail -n 1`**：只显示最后一行。

这里，`ls` 和 `tail` 是完全独立的程序，但通过管道连接，`ls` 的输出被直接传递给 `tail` 作为输入。你还可以将最终输出重定向到文件：

```bash
ls -l / | tail -n 1 > last_line.txt
```

这会将最终的输出保存到 `last_line.txt` 文件中，而不是显示在终端上。

### 实例：使用 `cat` 和重定向

假设你有一个文件 `hello.txt`，其中包含单词 "hello"。你可以使用 `cat` 来复制文件的内容：

```bash
cat hello.txt > hello_copy.txt
```

这会将 `hello.txt` 的内容复制到 `hello_copy.txt`。如果你想追加内容而不是覆盖：

```bash
echo "world" >> hello_copy.txt
```

现在 `hello_copy.txt` 将包含两行，分别是 "hello" 和 "world"。



## 管道与数据流重定向示例

在 Unix/Linux 中，通过管道和重定向可以灵活地处理各种数据流。接下来以一个示例展示如何通过管道和其他命令处理 HTTP 响应头信息。

### 使用 `curl` 获取 HTTP 头并过滤内容

首先，使用 `curl` 获取一个网站的 HTTP 响应头信息。我们可以通过 `curl` 的 `-sI` 参数（`-s` 静默模式，`-I` 只获取头部）来获取 Google 的 HTTP 头：

```bash
curl -sI https://www.google.com
```

这将输出所有 HTTP 头信息。为了只提取其中的 `Content-Length`，我们可以将 `curl` 的输出通过管道传递给 `grep` 命令，并使用 `-i` 参数忽略大小写，查找 `Content-Length`：

```bash
curl -sI https://www.google.com | grep -i content-length
```

这个命令会返回类似 `Content-Length: 437` 的行。接下来，可以使用 `cut` 命令进一步提取内容长度值。

### 使用 `cut` 提取特定字段

`cut` 命令可以基于分隔符提取特定字段。假设我们想要提取 `Content-Length` 后的数字部分，可以使用空格作为分隔符，并选择第二个字段：

```bash
curl -sI https://www.google.com | grep -i content-length | cut -d' ' -f2
```

这个命令会返回 `437`，即内容长度值。通过这种方式，我们可以链式组合多个命令来处理复杂的数据。

### 管道操作扩展到非文本数据

尽管管道主要用于文本数据处理，但它同样适用于其他类型的数据，如图像或视频。例如，你可以使用管道处理图像文件，甚至可以通过 Chromecast 流式传输视频。

## 使用 `sudo` 提升权限

在 Unix/Linux 系统中，`root` 用户（超级用户）拥有对系统的完全控制权限。大多数情况下，普通用户不以 `root` 身份运行命令，因为这会带来安全风险。然而，有时你需要以 `root` 用户身份执行某些操作，这时可以使用 `sudo` 命令。

- **`sudo`**：允许你以超级用户身份执行命令。用法如下：

```bash
sudo command
```

例如，修改系统文件或安装软件时，你可能需要使用 `sudo`：

```bash
sudo apt update
```

这会以 `root` 权限更新软件包列表。

### 操作系统的文件系统与内核参数

在 Linux 系统中，`/sys` 文件系统允许你通过文件形式访问和修改内核参数。虽然这些“文件”看起来像普通文件，但实际上它们代表的是内核的不同配置项。

### 修改屏幕亮度示例

在某些设备上，你可以通过访问 `/sys/class/backlight` 来调整屏幕亮度。例如，以下是如何查看并修改屏幕亮度的操作：

1. **查看当前亮度**：

    ```bash
    cat /sys/class/backlight/intel_backlight/brightness
    ```

    这会返回当前屏幕的亮度值。

2. **尝试修改亮度**：

    如果你尝试直接修改亮度：

    ```bash
    echo 500 > /sys/class/backlight/intel_backlight/brightness
    ```

    你可能会遇到权限问题，得到 `Permission denied` 错误。因为修改内核参数需要超级用户权限。

3. **使用 `sudo` 修改亮度**：

    为了解决权限问题，你可以使用 `sudo` 提升权限：

    ```bash
    sudo echo 500 > /sys/class/backlight/intel_backlight/brightness
    ```

通过这种方式，你可以修改系统的关键参数，但需要小心操作，因为对系统内核参数的错误修改可能会导致系统不稳定。





## `sudo` 和权限问题的处理

在 Unix/Linux 系统中，当你尝试修改系统文件或内核参数时，通常需要使用 `root` 权限。例如，在尝试修改屏幕亮度时，如果没有管理员权限，系统会返回 **"Permission denied"** 错误。以下是处理这种情况的几种方法和解释。

### 问题描述：`sudo echo` 无法解决权限问题

当你运行以下命令时：

```bash
sudo echo 500 > /sys/class/backlight/intel_backlight/brightness
```

尽管使用了 `sudo`，你仍会遇到权限被拒绝的问题。这是因为 `echo` 的输出重定向（`>`）是由 Shell 处理的，而不是 `sudo`。也就是说，`sudo` 提升了 `echo` 命令的权限，但实际尝试打开 `brightness` 文件进行写入的是 Shell，它运行在当前用户权限下，而不是 `root`。

### 解决方法 1：使用 `sudo su` 切换到 `root` Shell

你可以通过 `sudo su` 命令完全切换到 `root` Shell。这样，所有接下来的命令都将以 `root` 用户身份运行。

```bash
sudo su
```

输入密码后，提示符会从 `$` 变为 `#`，这表明你现在以 `root` 用户身份操作。然后，你可以成功执行修改亮度的命令：

```bash
echo 500 > /sys/class/backlight/intel_backlight/brightness
```

这时你不会再遇到权限问题，因为所有操作都是以 `root` 用户身份执行的。

### 解决方法 2：使用 `sudo tee` 命令

如果你不想切换到 `root` Shell，可以使用 `tee` 命令进行文件写入。`tee` 命令可以将输入同时写入文件和标准输出，它允许你通过 `sudo` 提升权限来写入文件。

```bash
echo 500 | sudo tee /sys/class/backlight/intel_backlight/brightness
```

在这个命令中，`echo` 生成的输出被通过管道传递给 `tee`，并且 `tee` 以 `root` 权限运行，能够成功写入 `brightness` 文件。

### `tee` 的工作原理

`tee` 是一个非常有用的工具，它可以将标准输入的内容写入文件，同时将内容输出到屏幕上。这意味着你可以在修改文件时看到修改的内容，而不需要额外的 `cat` 或 `echo` 操作。例如：

```bash
echo "log entry" | sudo tee -a /var/log/mylogfile
```

这个命令会将 `"log entry"` 追加到 `/var/log/mylogfile` 文件中，同时也会在终端中显示该条日志。

## 控制 Scroll Lock LED 示例

在现代计算机上，键盘上的 Scroll Lock 键和对应的 LED 灯几乎没有实际用途。通过访问系统的 `/sys/class/leds/` 目录，你可以控制键盘上的 Scroll Lock LED，并将其用于一些自定义目的，例如通知新邮件到达。以下是一个示例操作：

### 检查 Scroll Lock LED 亮度

首先，通过 Shell 进入 Scroll Lock LED 的控制目录：

```bash
cd /sys/class/leds/input0::scrolllock
```

在这个目录中，有一个名为 `brightness` 的文件，表示 Scroll Lock LED 的当前状态。值为 `0` 表示 LED 关闭，`1` 表示 LED 开启。

查看当前 Scroll Lock LED 的状态：

```bash
cat brightness
```

### 控制 Scroll Lock LED

要手动打开 Scroll Lock LED，可以将 `1` 写入 `brightness` 文件：

```bash
echo 1 | sudo tee brightness
```

这会点亮 Scroll Lock LED。同样，要关闭它，可以将 `0` 写入：

```bash
echo 0 | sudo tee brightness
```

### 自动化：使用 LED 作为新邮件通知

可以编写一个简单的脚本，将 Scroll Lock LED 与新邮件通知相关联。例如，每当收到新邮件时，LED 会点亮。你可以通过编写一个脚本，在检测到新邮件时执行 `echo 1 | sudo tee brightness`，并在邮件处理完毕后关闭 LED。

### 使用 `xdg-open` 打开文件

`xdg-open` 是一个方便的工具，可以根据文件类型自动打开合适的程序。在 Linux 系统上，你可以使用以下命令打开文件：

```bash
xdg-open file.html
```

这会使用默认的浏览器打开 `file.html` 文件。相似地，在 macOS 上可以使用 `open` 命令，Windows 上也有类似工具。

通过今天的课程，你已经学会了如何使用 Shell 执行基础的系统操作，控制硬件（如键盘 LED），并通过命令行工具如 `xdg-open` 打开文件。后续课程将进一步探讨如何自动化任务，编写 Shell 脚本，并在终端中进行条件判断和循环控制。

在下次课程中，我们将深入了解如何编写自动化脚本来执行复杂的任务，例如编写脚本使程序在失败时自动重启，非常适合测试环境中反复运行的场景。